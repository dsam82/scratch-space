# DMAP

`dmap` is basically a simple global registry that stores `(zone, name, meta, data)`.

Usage is divided into mainly two functions:

1. `set(name, meta, data)`: sets `s=keccak256(msg.sender, name)` slot to `meta` and `s+1` slot to `data`.
2. `get(name)`: returns `s=keccak256(msg.sender, name)` slot as `meta` and `s+1` as `data`.

Decompiled using [ethervm's decompiler](https://ethervm.io/decompile/0x90949c9937A11BA943C7A72C3FA073a37E3FdD96).

```solidity
fallback() external payable {
	assembly {
	    if eq(36, calldatasize()) {
	        mstore(0, sload(calldataload(4)))
	        mstore(32, sload(add(1, calldataload(4))))
	        return(0, 64)
	    }
	    let name := calldataload(4)
	    let meta := calldataload(36)
	    let data := calldataload(68)
	    mstore(0, caller())
	    mstore(32, name)
	    let slot := keccak256(0, 64)
	    log4(0, 0, caller(), name, meta, data)
	    sstore(add(slot, 1), data)
	    if iszero(or(xor(100, calldatasize()), and(LOCK, sload(slot)))) {
	        sstore(slot, meta)
	        return(0, 0)
	    }
	    if eq(100, calldatasize()) {
	        mstore(0, shl(224, 0xa1422f69))
	        revert(0, 4)
	    }
	    revert(0, 0)
	}
}
```

## Examples

Let's manually step through `dmap` bytecode using set and get example.

Create `set` calldata using `abi.encodePacked(SEL, name, meta, data)` where SEL is a `4byte` selector and others are `bytes32`. So, for `set` calls, calldata length should be **100** bytes. And, `get` calldata should be **36** bytes. using `abi.encodePacked(SEL, s)` where `s` is the storage slot from `keccak256(msg.sender, name)`.

First start with a `get` example.

1. Set up the free-memory pointer.

```bash
0000    60  PUSH1 0x80
0002    60  PUSH1 0x40
0004    52  MSTORE

MEMORY:
0040: 0x0000000000000000000000000000000000000000000000000000000000000080
```

2. Check `calldatasize` to be equal to _36_ as `get` calldata = _36_ bytes.

```bash
0005    36  CALLDATASIZE
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000024

0006    60  PUSH1 0x24
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000024
0001: 0x0000000000000000000000000000000000000000000000000000000000000024

0008    03  SUB
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000000

0009    60  PUSH1 0x22
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000022
0001: 0x0000000000000000000000000000000000000000000000000000000000000000

000B    57  *JUMPI
STACK: 0
```

3. load slot to stack

```bash
000C    60  PUSH1 0x04
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000004

000E    35  CALLDATALOAD
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000001
```

4. load storage slot to stack and store to `mem[0x00:0x20]`

```bash
000F    54  SLOAD
STACK: 1
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0010    60  PUSH1 0x00
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000000
0001: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0012    52  MSTORE
STACK: 0
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
0040: 0x0000000000000000000000000000000000000000000000000000000000000080
```

5. load s+1 slot to stack

```bash
0013    60  PUSH1 0x04
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000004
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
0040: 0x0000000000000000000000000000000000000000000000000000000000000080

0015    35  CALLDATALOAD
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000001
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0016    60  PUSH1 0x01
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000001
0001: 0x0000000000000000000000000000000000000000000000000000000000000001
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0018    01  ADD
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000002
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0019    54  SLOAD
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000000
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
```

6. store loaded slot to `mem[0x20:0x40]`

```bash
001A    60  PUSH1 0x20
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000020
0001: 0x0000000000000000000000000000000000000000000000000000000000000000
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

001C    52  MSTORE
STACK: 0
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
0020: 0x0000000000000000000000000000000000000000000000000000000000000000
```

7. return `mem[0x00:0x40]`

```bash
001D    60  PUSH1 0x40
001F    60  PUSH1 0x00
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000040
0001: 0x0000000000000000000000000000000000000000000000000000000000000000
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
0020: 0x0000000000000000000000000000000000000000000000000000000000000000

0021    F3  *RETURN
```

Now, let's walkthrough a `set` case.

```
name: "dmap" = 0x6e616d6500000000000000000000000000000000000000000000000000000000
meta: "meta" = 0x6d65746100000000000000000000000000000000000000000000000000000000
data: "data" = 0x6461746100000000000000000000000000000000000000000000000000000000

calldata: `abi.encodePacked(0x00000000,name,meta,data)` = 0x000000006e616d65000000000000000000000000000000000000000000000000000000006d657461000000000000000000000000000000000000000000000000000000006461746100000000000000000000000000000000000000000000000000000000
```

1. Jump to `0x22` if `calldatasize > 36`

```bash
0022    5B  JUMPDEST
```

2. push `name=calldata[0x04:0x24]`, `meta=calldata[0x24:0x44]`, `calldata[0x44:0x64]` to stack

```bash
0023    60  PUSH1 0x04
0025    35  CALLDATALOAD
0026    60  PUSH1 0x24
0028    35  CALLDATALOAD
0029    60  PUSH1 0x44
002B    35  CALLDATALOAD

STACK: 3
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

3. store msg.sender at mem[0x00:0x20]

```bash
002C    33  CALLER
002D    60  PUSH1 0x00
002F    52  MSTORE

STACK: 3
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
```


4. store `name` at mem[0x20:0x40]

```bash
0030    82  DUP3
0031    60  PUSH1 0x20
0033    52  MSTORE

STACK: 3
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000
```

5. calculate `keccak256(mem[0x00:0x40])` to find the storage slot

```bash
0034    60  PUSH1 0x40
0036    60  PUSH1 0x00
0038    20  SHA3

STACK: 4
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000
```

6. log the event `(0, 0, msg.sender, name, meta, data)`

```bash
0039    81  DUP2
003A    83  DUP4
003B    85  DUP6
003C    33  CALLER
003D    60  PUSH1 0x00
003F    80  DUP1

STACK: 9
0000: 0
0001: 0
0002: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0003: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0005: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000

0040    A4  LOG4
STACK: 4
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000
```

> Store `data` at `slot + 1`

7. duplicate `data` to stack top and push `1`

```bash
0041    81  DUP2
STACK: 5
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0042    60  PUSH1 0x01
STACK: 7
0000: 01
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

8. duplicate slot and add 1.

```bash
0044    82  DUP3
0045    01  ADD
STACK: 6
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab923 (slot + 1)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

9. store at `storage[slot+1] = data`

```bash
0046    55  SSTORE
STACK: 4
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

> Check if

10.
```bash
0047    80  DUP1
0048    54  SLOAD
0049    60  PUSH1 0x01
004B    16  AND
004C    36  CALLDATASIZE
004D    60  PUSH1 0x64
004F    18  XOR
0050    17  OR
0051    60  PUSH1 0x58
0053    57  *JUMPI
```
